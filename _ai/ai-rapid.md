---
layout: post
title: "AI 时代的敏捷开发：AI + Rapid"
date: 2026-01-01 18:30:00 +0800  # 标准格式
description: |
  这篇文章《AI 时代的敏捷开发：AI + Rapid》（AI-Rapid）主要探讨了在人工智能技术爆发的背景下，如何通过 AI 赋能传统的“敏捷开发”模式，以实现更高效、更智能的软件交付。"

---

这篇文章《AI 时代的敏捷开发：AI + Rapid》（AI-Rapid）主要探讨了在人工智能技术爆发的背景下，如何通过 AI 赋能传统的“敏捷开发”模式，以实现更高效、更智能的软件交付。

# 一、高效生产力工作流

**^\_^ 人类 ^\_^  **拥有 AI 无法替代的核心资产：**架构洞察力、对业务逻辑的深度理解以及对代码质量的“嗅觉”**。

在 2026 年的开发环境下，**Manus、Cursor 和 v0** 不仅仅是工具，它们分别代表了**决策助手、执行终端和 UI/原型引擎**。将它们结合起来，你可以从“码农”转变为“技术导演”。

以下是为你量身定制的高效生产力工作流：

------

## 1. 角色分工：构建你的 AI 智囊团

要提高生产力，首先要明确这三个工具在你的工作流中扮演的角色：

| **工具**   | **核心角色**                | **你的操作点**                                               |
| ---------- | --------------------------- | ------------------------------------------------------------ |
| **Manus**  | **通用任务 Agent & 调研员** | 负责需求分析、竞品调研、技术选型方案对比、编写技术文档或 PRD。 |
| **v0.dev** | **前端原型 & UI 生成器**    | 负责快速生成高质量、响应式的 React/Next.js 组件代码，解决“冷启动”问题。 |
| **Cursor** | **主力开发环境 (IDE)**      | 负责核心逻辑编写、存量代码重构、全库上下文关联调试。         |

------

## 2. 黄金组合工作流：从想法到上线

### 第一阶段：需求起航（Manus）

不要直接写代码。先让 **Manus** 帮你梳理逻辑。

- **场景**：你需要开发一个复杂的仪表盘系统。
- **指令**：向 Manus 描述业务目标，让它生成**技术架构图**、**数据库 Schema 建议**以及**API 接口规范**。
- **价值**：利用 Manus 强大的 Agent 能力处理脏活累活（如查阅最新的第三方库文档），你负责审核它的设计是否符合架构原则。

### 第二阶段：视觉与交互快跑（v0）

有了功能列表后，将 UI 需求交给 **v0**。

- **场景**：需要一个带图表和多重过滤器的 Dashboard。
- **操作**：在 v0 中输入要求，或者直接上传一份手绘草图。v0 会生成基于 Tailwind CSS 和 shadcn/ui 的代码。
- **价值**：省去了你从零调试 CSS 和组件排版的时间，直接拿到“像素级”还原的生产级代码。

### 第三阶段：核心逻辑集成（Cursor）

最后，将 v0 生成的代码和 Manus 设计的逻辑在 **Cursor** 中落地。

- **操作**：
  1. 使用 **Cursor Agent Mode** (@Codebase) 让它理解你现有的项目结构。
  2. 将 v0 的代码粘贴进来，用 `Cmd+K` 指令：“按项目规范重构此组件，并接入 `useSWR` 进行数据请求”。
  3. 使用 **Composer** 功能，一次性修改多个文件（如 Action, Store, Component）。
- **价值**：这是你发挥资深经验的主战场。你通过 AI 快速铺量，然后重点检查并发处理、内存泄漏或安全性问题。

------

## 3. 3 条进阶建议

### 1. 从“手写代码”转向“Spec-Driven（规格驱动）”

资深工程师最强的是定义问题的能力。在 Cursor 或 Manus 中，先写好 `.cursorrules` 或技术规格文件（Spec）。**AI 越像初级开发，你越要像一个好的技术 Leader，提供清晰的约束。**

### 2. 利用 MCP (Model Context Protocol) 扩展边界

2026 年，Cursor 广泛支持 MCP 协议。你可以配置 MCP Server 让 Cursor 直接读取你的数据库 Schema、查看 GitHub Issues 甚至连接 Jira。这让你无需切换窗口，就能在 IDE 里完成全链路开发。

### 3. 把 AI 当作“代码评审员”

不要只让 AI 写代码，还要让它 review 你的代码。

- 提示词：“作为一名资深架构师，分析这段代码的潜在性能瓶颈，并检查是否符合 SOLID 原则。”

  这能帮你从不同的维度审视代码，避免因工作忙碌导致的低级疏忽。

# 二、Cursor

在初创公司中，速度和准确性是生存的关键。使用 Cursor 进行“快捷开发”不仅仅是让 AI 写代码，更是一套**从“想法”到“上线”的工程化流程**。

以下是初创公司利用 Cursor 实现极速开发的具体步骤：

------

## 第一阶段：环境与上下文准备 (Setting the Context)

AI 表现的好坏取决于你给它的“信息质量”。

1. 编写 instruction.md (需求文档)：

   不要直接开始对话。先在根目录创建一个 Markdown 文件，写明：

   - **核心功能**：APP 要解决什么问题？
   - **技术栈**：如 Next.js 15, Tailwind CSS, Supabase, Prisma。
   - **代码规范**：如“优先使用 Server Components”、“变量名遵循 camelCase”。

2. 配置 .cursorrules (全局规则)：

   在项目根目录创建此文件。这是 Cursor 的“灵魂”，它定义了 AI 每次生成代码时必须遵守的底线。

   > [!TIP]
   >
   > 示例规则：禁止使用过时的库、强制要求 TypeScript 类型检查、要求代码简洁且无占位符（No placeholders）。

3. 添加外部文档 (@Docs)：

   如果使用了较新的技术（如刚刚发布的某个 API），在 Settings > Features > Docs 中添加其官方文档链接。这样 AI 就能基于最新版而非 2023 年之前的旧数据写代码。

------

## 第二阶段：脚手架与架构设计 (Architecture & Scaffolding)

不要让 AI 一次性写完整套系统，要由大到小。

1. 利用 Composer (Cmd+I) 构建大框架：

   打开 Composer（Agent 模式），输入：“基于 instruction.md，帮我初始化项目结构，包括文件夹命名、核心依赖安装，以及基础的数据库 Schema。”

2. 设计数据库模型：

   在 Chat 框中使用 @Codebase 询问：“根据目前的需求，设计 Prisma 模型。请确保考虑了多租户和索引优化。”

3. 快速 UI 渲染 (V0 + Cursor)：

   初创公司常用的黑科技：先在 V0.dev 生成 UI 代码，然后复制到 Cursor 中，让 AI 进行逻辑填充和接口对接。

------

## 第三阶段：模块化迭代开发 (Iterative Development)

这是最核心的“快捷”环节，建议遵循 **"Plan -> Execute -> Review"** 循环。

1. 小步快跑：

   将功能拆解。例如：“先实现 Google 登录功能”，完成后再做“用户个人资料页”。

2. **活用 `@` 符号精准锁定**：

   - `@Files`：当你要修改特定文件时。
   - `@Web`：当你遇到报错，需要搜索最新的解决方案时。
   - `@Codebase`：当你需要让 AI 理解跨文件的逻辑（如：新加一个字段对全局的影响）时。

3. 使用 YOLO 模式进行快速调试：

   在设置中开启 YOLO 模式，允许 AI 在 Terminal 中自动运行安装命令或测试脚本，无需你手动点击“允许”，极大提升连贯性。

------

## 第四阶段：质量把控与部署 (QA & Deployment)

初创公司容易因为快而产生大量技术债。

1. AI 驱动的单元测试：

   选中一个组件或函数，按 Cmd+K 输入：“写一个 Vitest 测试案例，覆盖所有的边缘情况。”

2. 代码审查与重构：

   每完成一个功能，询问：“这段代码有潜在的性能漏洞或安全隐患吗？请帮我重构得更优雅。”

3. 自动化部署文档：

   让 AI 根据当前项目结构生成 Dockerfile 或 Vercel 部署指南。

## 初创公司 Cursor 提速表格对照

| **阶段**      | **传统方式**                            | **Cursor 快捷方式**                    | **提速比** |
| ------------- | --------------------------------------- | -------------------------------------- | ---------- |
| **项目起步**  | 手动配置环境、配置 Lint、写 Boilerplate | **Composer** 一键生成 + `.cursorrules` | 5x         |
| **功能开发**  | 查文档、手动敲代码、解决拼写错误        | **Tab 键补全** + **Cmd+K** 意图转换    | 3x         |
| **Debug**     | 翻 Stack Overflow、打日志、查类型       | **@Web** 搜索报错 + **Chat** 分析日志  | 10x        |
| **文档/测试** | 懒得写，导致后期混乱                    | **Cmd+K** 自动生成测试和 README        | 4x         |

## Monorepo（单仓）模式（推荐）

如果你将前端、后端和文档都放在一个大文件夹里管理，这是对 Cursor 最友好的结构，因为 AI 可以轻松跨目录读取上下文。

```
my-awesome-project/          # 项目根目录
├── docs/                    # 💡 核心：文档中心（AI 的知识库）
│   ├── prd/                 # 产品需求文档
│   ├── api/                 # 接口定义 (Swagger/OpenAPI)
│   ├── sql/                 # 数据库设计/DDL
│   ├── design/              # UI/UX 设计说明
│   └── guides/              # 最佳实践、统一错误码、代码规范
├── frontend/                # 前端源码（React/Vue/Next.js）
│   └── .cursorrules         # 前端专属指令（如：参考 docs/design）
├── backend/                 # 后端源码（Go/Java/Python）
│   └── .cursorrules         # 后端专属指令（如：参考 docs/sql）
└── .cursorrules             # 全局指令（统筹前后端协作）
```

- **优点：** 在全栈开发时，你可以同时 `@docs`、`@frontend` 和 `@backend`。
- **适用：** 个人开发者或小型敏捷团队，追求极速交付。

# 三、v0和Cursor

在 **v0 + Cursor** 的黄金组合中，最推荐的做法是：**在 v0 中生成“单个页面”或“核心 UI 模块”，然后在 Cursor 中完成“网站组装”和“逻辑打通”。**

------

### 为什么不建议在 v0 中直接生成“完整网站”？

虽然 v0 的能力在增强，但它的本质是 **UI 生成模型**。

- **上下文丢失：** 当你让 v0 生成一个包含 10 个页面的完整项目时，随着对话变长，它可能会忘记之前的 CSS 规范或组件逻辑，导致代码冗余。
- **路由限制：** v0 虽然能模拟路由，但它生成的往往是单文件内的状态切换，而不是标准的 Next.js 项目结构。
- **Cursor 更擅长“全局”：** Cursor 拥有整个项目的上下文（Context），它比 v0 更擅长处理跨文件的逻辑、数据库连接和复杂的路由配置。

------

### 推荐的协作工作流：v0 (设计) + Cursor (工程)

#### 第一阶段：在 v0 中打磨“视觉稿”

不要让 v0 做逻辑，只让它做**看得见的部分**。

1. **按页面拆分：** 比如先在 v0 里生成一个极具视觉冲击力的 `Landing Page`。
2. **获取代码：** 点击 v0 的 `Code` 按钮，直接复制它生成的 React/Tailwind 代码。
3. **优势：** v0 的审美通常比 Cursor（纯 LLM）要好得多，因为它专门针对 shadcn/ui 和现代网页设计进行了微调。

#### 第二阶段：在 Cursor 中进行“工程化”

将 v0 生成的代码片段丢进 Cursor：

1. **文件拆分：** 在 Cursor 中使用 `Cmd + K`，让它把 v0 的一大坨代码拆分成标准的 `components` 和 `page.tsx`。
2. **路由构建：** 让 Cursor 根据 v0 提供的设计，自动生成 `App Router` 结构（如 `/about`, `/dashboard`）。
3. **逻辑注入：** 在 Cursor 中连接真正的 API、配置身份验证（NextAuth）或连接数据库（Prisma/Supabase）。

------

### 协作建议表

| **任务**               | **推荐工具** | **理由**                             |
| ---------------------- | ------------ | ------------------------------------ |
| **整体 UI 风格/配色**  | **v0**       | 可视化反馈快，审美在线。             |
| **复杂交互组件**       | **v0**       | 处理动画、拖拽等视觉组件非常专业。   |
| **多页面跳转逻辑**     | **Cursor**   | 擅长处理文件夹结构和路由跳转。       |
| **API 调用与状态管理** | **Cursor**   | 能理解整个项目的业务逻辑和环境变量。 |
| **SEO 与 元数据配置**  | **Cursor**   | 适合进行细碎的项目配置。             |

------

### 总结建议

**你应该把 v0 当作你的“高级前端设计师”，把 Cursor 当作你的“全栈工程师”。**

- **在 v0 中：** 专注于一个一个页面的“画稿”，确保每一个页面的 UI 你都满意。
- **在 Cursor 中：** 把这些“画稿”拼凑成一个有灵魂、有逻辑的完整网站。

# 四、v0具体使用

你应该按照 **Next.js 的标准项目结构**（v0 默认基于 Next.js + Tailwind + shadcn/ui）将它们放入对应的代码目录。以下是标准的迁移步骤：

### 1. 准备项目基础环境

在 Cursor 中，如果还没有项目，建议先创建一个标准的 Next.js 项目，因为 v0 的代码高度依赖它的生态：

Bash

```
npx create-next-app@latest my-project --typescript --tailwind --eslint
```

*务必安装 **shadcn/ui**，因为 v0 生成的组件几乎全部基于它。*

### 2. 放置页面的正确位置

根据你使用的是 **App Router**（目前最主流）还是 **Pages Router**，位置如下：

#### A. 页面文件 (Pages)

- **路径：** `src/app/` (App Router) 或 `src/pages/` (Pages Router)。
- **操作：** * 如果你在 v0 生成的是“首页”，就把代码复制到 `src/app/page.tsx`。
  - 如果你生成的是“关于我们”页面，就新建文件夹 `src/app/about/page.tsx`。

#### B. 组件文件 (Components) —— **关键点**

v0 生成的代码通常包含很多 UI 组件（如 Button, Card, Navbar）。

- **路径：** `src/components/`
- **操作：** 1.  先看 v0 代码顶部的 `import` 部分。 2.  如果有引用 `@/components/ui/...`，你需要先在 Cursor 终端里用 shadcn 命令安装对应的组件（例如 `npx shadcn-ui@latest add button`）。 3.  如果是 v0 自己生成的自定义组件，在 `src/components/` 下新建 `.tsx` 文件并粘贴进去。

### 3. 利用 Cursor 进行高效集成的技巧

这是最推荐的工作流，能让 Cursor 帮你自动处理琐碎的配置：

1. **直接粘贴并让 Cursor 修复：** 在一个新文件中粘贴 v0 的代码。代码由于缺少依赖（比如某些 icon 库或 shadcn 组件）肯定会报红。
2. **使用 `Cmd + L` (Chat)：** 全选代码，告诉 Cursor：“这是我从 v0 生成的代码，请帮我处理所有的 import 错误，安装缺失的依赖，并把其中的子组件拆分到 components 文件夹中。”
3. **处理全局样式：** v0 有时会用到特殊的 Tailwind 配置。检查 v0 代码中是否有自定义的 `tailwind.config.js` 配置或 `globals.css` 样式，并对应地合并到你的 Cursor 项目中。

### 总结

- **页面逻辑：** 放 `src/app/` 目录下对应的文件夹。
- **UI 组件：** 放 `src/components/` 目录。
- **静态资源：** 图片等放 `public/` 目录。
- **不要放 `docs`：** 那个目录下的代码不会被执行，只能看。

**建议：** 你可以先在 Cursor 里新建一个 `page.tsx`，把 v0 最核心的一个页面丢进去，然后对着报错直接按 `Cmd + K` 让 Cursor 帮你“一键修复所有依赖”。
