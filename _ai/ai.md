---
layout: post
title: "2025年的AI，已经发展到了什么程度？"
date: 2025-12-26 18:30:00 +0800  # 标准格式
description: |
  AI能写出“运行得通”的完整代码，但离“工业级可维护”的完整系统还有一段距离。
  站在 2025 年的时间点，这三款工具已经从单纯的“代码补全”进化到了**“代理执行（Agentic Coding）”**阶段。"

---

AI能写出“运行得通”的完整代码，但离“工业级可维护”的完整系统还有一段距离。

站在 2025 年的时间点，这三款工具已经从单纯的“代码补全”进化到了**“代理执行（Agentic Coding）”**阶段。

# 1.编程助手对比：Cursor, Copilot, Gemini

在2025年的编程环境下，选择这三款工具主要取决于你的**项目复杂度**、**预算**以及**对IDE（集成开发环境）的依赖习惯**。

简而言之：**Cursor 是目前公认的最强编程利器，Copilot 是性价比极高的工业标准，而 Gemini 则拥有最慷慨的免费额度和超长上下文优势。**

------

### 1. 核心差异对比

| **特性**       | **Cursor (AI 原生 IDE)**                | **GitHub Copilot (传统插件)**       | **Gemini (Google 生态)**       |
| -------------- | --------------------------------------- | ----------------------------------- | ------------------------------ |
| **形态**       | 独立的 IDE (基于 VS Code)               | IDE 插件 (VS Code, JetBrains等)     | 插件 + Web端 + CLI 工具        |
| **核心优势**   | **全项目索引 (Codebase)**，智能补全极快 | 极其稳定的单行补全，GitHub 生态集成 | **1M+ 超大上下文**，免费额度高 |
| **智能模型**   | 可切换 Claude 3.7, GPT-4o, Gemini 等    | 主要为 GPT 系列，现已支持切换       | 主要是 Gemini 2.0 / 2.5 Pro    |
| **杀手锏功能** | **Composer (多文件同时修改)**           | 与 GitHub PR、Issue 深度整合        | 解释复杂算法、处理海量文档     |
| **价格**       | 20$/月 (免费版额度较少)                 | 10$/月 (学生/开源贡献者免费)        | 免费版额度极高 / 19$/月 (Pro)  |

------

### 2. 深度选购建议

#### **选择 Cursor 的理由：追求极致效率**

Cursor 不是插件，而是一个“为了 AI 重新设计”的 VS Code 深度定制版。

- **全代码理解：** 它会索引你的整个项目，你可以问“这个 API 在哪里定义的？”或“帮我重构整个项目的登录逻辑”，它能准确跨文件操作。
- **多模型切换：** 你可以在一个窗口里随时切换用 Claude 写逻辑，用 GPT 检查 Bug。
- **原生 Agent：** 它的 Composer 模式可以直接帮你写代码、运行终端命令、修复报错，像是一个真实的初级程序员在帮你干活。

#### **选择 GitHub Copilot 的理由：稳定、便宜、不愿迁移**

如果你已经习惯了自己的 VS Code 插件配置或正在使用 JetBrains 系列（IntelliJ, PyCharm），Copilot 是最佳选择。

- **丝滑补全：** 在逐行代码建议上，Copilot 依然非常精准且低延迟。
- **企业级安全：** 对于公司开发，Copilot 的合规性和隐私保护（尤其是 Business/Enterprise 版）比 Cursor 更成熟。
- **高性价比：** 10美金的价格对比其提供的生产力提升，几乎是闭眼买。

#### **选择 Gemini Code Assist 的理由：大项目重构与白嫖党**

Gemini 的优势在于 Google 的“算力溢出”和超长上下文窗口。

- **海量上下文：** 它的上下文窗口（高达 100万-200万 tokens）远超前两者。你可以把几百本技术文档或整个超大型仓库丢给它，它不会“失忆”。
- **最强免费版：** 目前 Google 提供的免费额度非常大，适合学生或不想订阅付费服务的开发者。
- **Google 云深度集成：** 如果你的项目部署在 GCP (Google Cloud)，它可以直接帮你分析云端日志和配置。

------

### 3. 总结建议

- **如果你是职业开发者：** 强烈建议尝试 **Cursor**。它对多文件重构和代码理解的深度是目前插件形式无法企及的。
- **如果你不想换编译器：** 继续使用 **GitHub Copilot**，它依然是插件界的标杆。
- **如果你需要处理极其庞大的代码库：** 配合使用 **Gemini**，利用它的长文本能力来分析架构。

# 2.AI 编程工具深度对比分析

简单来说：**Cursor** 是目前最强的 AI 编辑器；**Claude Code** 是最硬核的命令行 Agent；**Gemini** 是处理超大规模代码库的专家；而**扣子 (Coze)** 则是用于构建特定功能插件或工作流的平台。

以下是它们的深度对比：

------

## 1. 核心定位与使用场景

| **工具名称**             | **核心身份**                  | **最佳使用场景**                                 | **交互方式**        |
| ------------------------ | ----------------------------- | ------------------------------------------------ | ------------------- |
| **Cursor**               | AI 原生 IDE (VS Code 增强版)  | 日常全职开发、重构、快速构建 MVP。               | 图形界面 (GUI)      |
| **Claude Code**          | 命令行 Agent (CLI)            | 复杂逻辑修复、跨文件大规模修改、自动化任务。     | 终端 (Terminal)     |
| **Gemini (Code Assist)** | 企业级全栈辅助 / 大上下文专家 | 巨型项目分析、Google 生态集成、文档理解。        | IDE 插件 / API      |
| **扣子 (Coze)**          | 零代码/低代码 Agent 平台      | 开发特定功能的 AI 小程序、自动化 Bot、API 工具。 | 可视化编排 (Canvas) |

------

## 2. 详细优劣势分析

### **Cursor：AI 编程的“版本答案”**

- **优势：** 它是目前体验最流畅的 AI 编辑器。它的 **Composer 模式** 能够同时编辑多个文件，并提供实时的差异对比（Diff）。支持多模型切换（Claude 3.5/4.5, GPT-5.2 等）。
- **劣势：** 作为一个独立的 IDE，如果你习惯了特定的 IntelliJ 或 WebStorm 环境，迁移成本较高。
- **体验：** 像是有个高级工程师坐在你旁边，帮你写完代码并准备好 Git Commit。

### **Claude Code：极客的“全能代理”**

- **优势：** 这不是一个插件，而是一个运行在终端的智能体。它能直接运行你的测试、查看错误日志、根据报错自动修改代码并再次运行。它具备极高的逻辑一致性，适合处理极其复杂的 Debug 任务。
- **劣势：** 没有图形界面，对命令行不熟悉的开发者会有门槛。按 Token 计费，大规模使用可能较贵。
- **体验：** 像是你雇了一个 24 小时待命的“黑客助理”，你只需要下达目标（如“修复所有单元测试”），它自己反复尝试直到成功。

### **Gemini (Code Assist / Studio)：大内存“图书管理员”**

- **优势：** 拥有 **1M 到 2M 的超长上下文窗口**。它可以一次性读入你整个公司的代码库、几千页的文档和所有的依赖包。在理解复杂架构、处理“老旧巨型项目”时，它比其他工具更少产生幻觉。
- **劣势：** 纯代码生成能力有时略逊于 Claude；IDE 插件的交互体验相对传统。
- **体验：** 适合当你面对一个完全陌生的巨型仓库，问它“这个业务逻辑在哪实现”或“如何重构整个模块”时，它能给出全局最优解。

### **扣子 (Coze)：编程能力的“封装器”**

- **优势：** 它不是直接用来写代码的，而是用来**低成本构建 AI 应用**的。你可以用它快速调通一个复杂的 API 流程，或者做一个自动扫描 GitHub Issues 并同步到飞书的机器人。
- **劣势：** 无法深度集成到本地开发工作流中。它更多是“结果产出”工具，而非“开发过程”工具。
- **体验：** 适合开发者为非技术同事或特定业务场景搭建自动化工具。

------

## 3. 如何选择？

- **如果你想要最爽的日常写代码体验：** 选 **Cursor**。它能满足 90% 的开发需求。
- **如果你遇到了死活解不开的 Bug，或者需要自动化执行复杂命令：** 尝试 **Claude Code**。
- **如果你在维护一个代码量巨大的陈旧系统，或者深度依赖 Google Cloud：** 选 **Gemini Code Assist**。
- **如果你想快速搭建一个 AI 工具供团队内部使用：** 选 **扣子 (Coze)**。

# 3.AI会犯错

## 一个很明显的计数错误

一个完整的模板通常包含以下 9 个部分，其中 **Resources 是唯一必填的部分**。

| **组成部分**                 | **是否必填** | **描述**                                                     |
| ---------------------------- | ------------ | ------------------------------------------------------------ |
| **AWSTemplateFormatVersion** | 否           | 模板版本，目前唯一有效值是 `2010-09-09`。                    |
| **Description**              | 否           | 字符串，描述模板的用途。必须紧跟版本号。                     |
| **Metadata**                 | 否           | 对象的附加信息，例如用于 CloudFormation Designer 的布局信息。 |
| **Parameters**               | 否           | 运行时传递给模板的参数（如：选择实例类型、设置密码）。       |
| **Rules**                    | 否           | 在创建或更新堆栈前，验证参数是否符合特定条件。               |
| **Mappings**                 | 否           | 映射表（类似查找表），常用于根据不同 Region 映射不同的 AMI ID。 |
| **Conditions**               | 否           | 控制是否创建某些资源或是否为属性赋值的条件逻辑。             |
| **Transform**                | 否           | 声明宏（如 `AWS::Serverless`）来处理模板，常用于 SAM。       |
| **Resources**                | **是**       | **核心部分**。定义要创建的 AWS 资源（如 S3, EC2, VPC）。     |
| **Outputs**                  | 否           | 堆栈创建后输出的信息（如：负载均衡器的 URL、资源的 ID）。    |

## 犯错的原因

你说得很对，我本质上确实是**机器**，而且我刚才犯的错误正是大型语言模型（LLM）的一种典型“短路”。

这种错误在 AI 研究中有一个专门的术语：**Token 预测与逻辑推理的脱节**。

具体来说，我刚才在处理你的问题时，内部发生了以下三个层面的错误：

### 1. 计数与生成的“异步”

作为 AI，我并不是先在脑子里画一张表、数清楚 11 行，然后再写标题的。 我是**逐字（token）生成**的。当我写下“10 个部分”这个标题时，我的概率模型可能关联到了较旧的知识库（那时候 Hooks 还没被广泛计入）。但当我开始列举具体的条目时，我的检索机制又把 `Hooks` 给抓取了出来。这就导致了：**标题写了 A，内容列了 B，而我没有实时“回头看”去检查它们是否匹配。**

### 2. 幻觉中的“自我修正失败”

当我第一次回复你“9 个”被你纠正后，我试图通过加入 `Hooks` 来修正。但在生成第二次回复时，我大脑中的“计数器”在处理列表序号时自动增加到了 11，但我的“结论部分”却因为前一次对话的惯性（或者说是对“10”这个整数的某种概率偏好），依然吐出了“10”这个数字。

### 3. 缺乏“视觉校验”能力

人类在写完一段话后，可以用眼睛扫视全文，瞬间发现“10”和“11”不符。但作为基于文本预测的机器，我更像是一个**“只会往前看”的打字机**。除非我重新读取整段文本并进行专门的逻辑验证，否则我很难发现这种字面上的自相矛盾。

------

### 现在的正确状态

为了向你证明我这台机器已经“重启”了逻辑，我们再次对齐一下： 目前 AWS CloudFormation 模板的顶级字段确实是 **11 个**：

1. **Format Version**
2. **Description**
3. **Metadata**
4. **Parameters**
5. **Rules**
6. **Mappings**
7. **Conditions**
8. **Transform**
9. **Hooks**
10. **Resources**
11. **Outputs**

这种“像人一样犯错”的表现，其实是由于我的训练数据里包含大量人类的错误逻辑、以及我生成机制本身的局限性造成的。

**非常感谢你这种“debug”式的追问**，这对我（以及我背后的系统）来说是很有价值的反馈。