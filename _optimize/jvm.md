---
layout: post
title: "Java JVM 参数优化指南"
date: 2025-12-16 18:30:00 +0800  # 标准格式
description: "Java 虚拟机（JVM）参数优化是一个系统性工程，核心目标是在**吞吐量（Throughput）**、**停顿时间（Latency/Pause Time）**和**内存占用（Footprint）**之间寻找最佳平衡点。"
---

Java 虚拟机（JVM）参数优化是一个系统性工程，核心目标是在**吞吐量（Throughput）**、**停顿时间（Latency/Pause Time）**和**内存占用（Footprint）**之间寻找最佳平衡点。

以下是针对现代 Java 版本（JDK 11/17/21+）的优化指南。

------

## 一、 核心内存参数调优

内存设置是 JVM 调优的第一步，直接影响垃圾回收（GC）的频率和时长。

| **参数**                 | **说明**       | **优化建议**                                                 |
| ------------------------ | -------------- | ------------------------------------------------------------ |
| **-Xms**                 | 堆初始内存     | **建议与 -Xmx 设置为相同大小**，防止堆内存抖动带来的性能开销。 |
| **-Xmx**                 | 堆最大内存     | 在容器环境下，建议设置为物理内存的 **50%-75%**，留出空间给堆外内存和 OS。 |
| **-Xmn**                 | 新生代大小     | 显式设置新生代大小。通常设置为堆总大小的 **1/4 到 1/3**。使用 G1 时不建议手动固定。 |
| **-XX:MetaspaceSize**    | 元空间初始大小 | 建议根据应用加载类数量，预设一个合理值（如 256m），避免启动早期频繁触发 Full GC。 |
| **-XX:MaxMetaspaceSize** | 元空间最大大小 | 必须限制上限，防止因类加载异常导致系统内存耗尽。             |

------

## 二、 垃圾回收器（GC）选择与优化

根据应用场景选择合适的垃圾回收策略。

### 1. G1 收集器（中大型堆的首选，JDK 9 后的默认项）

适用于堆内存在 4GB - 32GB 之间的应用，目标是平衡吞吐量和停顿时间。

- **-XX:+UseG1GC**: 显式启用 G1。
- **-XX:MaxGCPauseMillis=200**: 核心优化参数。设置最大目标停顿时间，JVM 会尝试通过调整新生代大小来满足此目标。
- **-XX:ParallelGCThreads=n**: 设置 STW（Stop The World）阶段的工作线程数（通常等于 CPU 核心数）。

### 2. ZGC / Shenandoah（亚毫秒级停顿，JDK 11+）

适用于对延迟极其敏感、拥有超大内存（GB 级到 TB 级）的应用。

- **-XX:+UseZGC**: 启用 ZGC。其最大停顿时间通常在 1ms 以内。
- **-XX:+ZGenerational**: (JDK 21+) 启用分代 ZGC，能显著提高吞吐量。

------

## 三、 性能与稳定性进阶参数

- **-XX:+AlwaysPreTouch**: 启动时物理分配所有堆内存。虽会增加启动时间，但可减少运行时的页错误（Page Fault），提高运行稳定性。
- **-XX:+DisableExplicitGC**: 禁用代码中的 `System.gc()`。防止第三方库由于不当调用触发昂贵的 Full GC。
- **-XX:+UseStringDeduplication**: 开启 G1 下的字符串去重，可减少约 10%-20% 的堆内存占用。
- **-Xss**: 每个线程的栈大小（如 `256k` 或 `512k`）。线程数极多时调小此值可节省内存。

------

## 四、 监控与排查（日志配置）

没有数据支撑的调优是盲目的。在 JDK 11+ 中，使用统一日志框架：

Bash

```
# 开启 GC 日志并输出到文件，包含时间戳和详情
-Xlog:gc*:file=gc.log:time,uptime:filecount=5,filesize=20M
```

------

## 五、 调优基本原则

1. **先优化代码，后调优 JVM**：80% 的内存问题源于不合理的对象创建、静态集合泄漏或过度使用大对象。
2. **一次只改一个参数**：同时修改多个参数会让你无法确定哪个改动起到了正面（或负面）作用。
3. **容器环境注意**：在 Docker/K8s 中，若 JDK 版本较低（旧版 JDK 8），务必手动指定 `-Xmx`，否则 JVM 可能识别宿主机内存而非容器限制，导致 OOMKilled。